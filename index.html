<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Planetary Assault WebGL</title>
	</head>
	<body>
		
		<div id="container" width="100%" height="100%" margin="0px" padding="0px"></div>
		
	</body>
	
	<script src="js/Three.js"></script>
	<script src="js/three.min.js"></script>

	<script type="text/javascript">

		/////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////

		// MyParticle

		MyParticle = function() {
			this.pos = new Three.vector3();
			this.vel = new Three.vector3();
			this.acc = new Three.vector3();

			this.max_vel = 40.0;
			//this.weight  = 1.0;

			this.acc_decay = 0.0;
			this.vel_decay = 1.0;
		};

		MyParticle.prototype = {

			constructor: MyParticle,

			update: function ( time ) 
			{
				this.vel.add(acc);
				this.vel.clampScalar(0.0, max_vel);
				
				this.pos.add(vel);

				this.acc.multiplyScalar(acc_decay);
				this.vel.multiplyScalar(vel_decay);
			},

			addForce: function( force )
			{
				this.acc.add(force);
			},

			setActive: function( value )
			{
				this.active = false;
				this.pos.z = 500000; // exceed the draw distance
			}

		};

		// MyParticleSystem

		MyParticleSystem = function(g, x, y, z, max) {

    		this.G = g;
    		this.center = new Three.vector3(x, y, z);
    		this.particlesCount = max;

    		this.pGeometry = new THREE.Geometry();
			this.pMaterial = new THREE.ParticleBasicMaterial({
					color: 0xFFFFFF,
					size: 20,
					map: THREE.ImageUtils.loadTexture("images/particle.png"),
					blending: THREE.AdditiveBlending,
					transparent: true
				});
		};

		MyParticleSystem.prototype = {

			constructor: MyParticleSystem,

			initialize: function()
			{
				// now create the individual particles
				for(var p = 0; p < this.particlesCount; p++) {
				
					// create a particle with random
					// position values, -250 -> 250
					var pX = Math.random() * 500 - 250,
						pY = Math.random() * 500 - 250,
						pZ = Math.random() * 500 - 250,
					    particle = new THREE.Vertex(
							new THREE.Vector3(pX, pY, pZ)
						);
					// create a velocity vector
					particle.velocity = new THREE.Vector3(
						0,				// x
						-Math.random(),	// y
						0);				// z

					// add it to the geometry
					pGeometry.vertices.push(particle);
				}
				
				// create the particle system
				particleSystem = new THREE.ParticleSystem(pGeometry, pMaterial);
				particleSystem.sortParticles = true;
				
				// auto-add to the scene
				scene.add(particleSystem);
			}


		}

		/*
		Then to instantiate it:

		var testGeo = new THREE.CubeGeometry(20, 20, 20);
		var testMat = new Three.MeshNormalMaterial();
		var thing = new MyObject3D(testGeo, testMat);*/





		// - RENDERING ATTRIBUTES

		var scene;
		var camera;
		var renderer;

		// width and height of the scene :
		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;

		// camera attributes
		var VIEW_ANGLE = 45;
		var ASPECT = WIDTH / HEIGHT;
		var NEAR = 0.1;
		var FAR = 10000;

		// - PROGRAM ATTRIBUTES

		var particleCount = 1800;
		var particles;
		var pMaterial;

		var particleSystem;

		///////////////////////////////////////////////////
		///////////////////////////////////////////////////

		launch();


		function launch() 
		{
			initRendering();
			initProgram();
			update();
		}

		function initRendering()
		{
			// Create the scene
			scene = new THREE.Scene();
			
			// Create a WebGL renderer and add it to the DOM.
			renderer = new THREE.WebGLRenderer();
			renderer.setSize(WIDTH, HEIGHT);
			renderer.setClearColorHex(0x333F47, 1);
			document.getElementById("container").appendChild(renderer.domElement);

			// Create a camera, zoom it out from the model a bit, and add it to the scene.
			camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
			camera.position.z = 300;
			scene.add(camera);


			// Create an event listener that resizes the renderer with the browser window.
		    window.addEventListener('resize', function() {
		    	WIDTH = window.innerWidth,
		        HEIGHT = window.innerHeight;
		        renderer.setSize(WIDTH, HEIGHT);
		        camera.aspect = WIDTH / HEIGHT;
		        camera.updateProjectionMatrix();
		    });

			/*
			// Create a light, set its position, and add it to the scene.
			var light = new THREE.PointLight(0xffffff);
				light.position.set(-100,200,100);
				scene.add(light);
			}*/
		}

		function initProgram()
		{

			particles = new THREE.Geometry();
			pMaterial = new THREE.ParticleBasicMaterial({
					color: 0xFFFFFF,
					size: 20,/*
					map: THREE.ImageUtils.loadTexture(
						"images/particle.png"
					),*/
					blending: THREE.AdditiveBlending,
					transparent: true
				});


			
			// now create the individual particles
			for(var p = 0; p < particleCount; p++) {
			
				// create a particle with random
				// position values, -250 -> 250
				var pX = Math.random() * 500 - 250,
					pY = Math.random() * 500 - 250,
					pZ = Math.random() * 500 - 250,
				    particle = new THREE.Vertex(
						new THREE.Vector3(pX, pY, pZ)
					);
				// create a velocity vector
				particle.velocity = new THREE.Vector3(
					0,				// x
					-Math.random(),	// y
					0);				// z

				// add it to the geometry
				particles.vertices.push(particle);
			}
			
			// create the particle system
			particleSystem = new THREE.ParticleSystem(particles, pMaterial);
			particleSystem.sortParticles = true;
			
			// add it to the scene
			scene.add(particleSystem);
		}

		// Renders the scene and updates the render as needed.
    	function update() {
	      	// Update
	      	//particleSystem.rotation.x += .2;

			// Render the scene.
			renderer.render(scene, camera);

    		// set up the next call
			requestAnimationFrame(update);
		}


		// Smart animation system
		window.requestAnimFrame = (function(){
		    return  window.requestAnimationFrame       ||
		            window.webkitRequestAnimationFrame ||
		            window.mozRequestAnimationFrame    ||
		            window.oRequestAnimationFrame      || 
		            window.msRequestAnimationFrame     || 
		            function(callback){
		              window.setTimeout(callback, 1000 / 60);
		            };
		})();

	</script>
</html>